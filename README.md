# JVU

[![Build Status](https://travis-ci.org/korzio/jvu.svg?branch=master)](https://travis-ci.org/korzio/jvu)

Json-schema Validator Utilities

[Json-schema](https://tools.ietf.org/html/draft-zyp-json-schema-04) is a declaration of document type in a json format.
Basic usage of a json schema is validation, but also it might bring a clear picture of protocols used in an application.

What are reasons to use json-schema?
- Validation (type checking)
- Protocols (database & API description)

Anything else?
Lots of things, but this package is about functional programming and awesome techniques, that can be achieved with json-schema usage:
- [Matching pattern](https://en.wikipedia.org/wiki/Pattern_matching)
- [Case Classes pattern](http://docs.scala-lang.org/tutorials/tour/case-classes.html)
- [if-less pattern](http://alisnic.github.io/posts/ifless/)

## Features

- Use any json-schema validator (which support basic protocol)
- Expose native environment API

// shorthands for native API
- jvu.add('', schema) or env.addSchema
- jvu('', object) or `validate/is`

// new API
- jvu('') or `generate`
- jvu.match({ '': value })
- jvu.find([''])

## Terms

- **validator** - a json-schema validator used for internal tasks
- **validation function** - a generated by path or schema function which checks any given argument among with a schema and returns isValid value

## List of supported json-schema validators

- **[djv](https://www.npmjs.com/package/djv)**

## Usage

Lets have an example - jsonSchema

```
jsonSchema = {
    "common": {
        "properties": {
            "type": {
                "enum": ["common"]
            }
        },
        "required": [
            "type"
        ]
    }
};
```

### initialize & add schema

Utils will create an empty environment with a given validator.
```
jvu = require('jvu')(validator);
```

Validator environment is available with a `jvu.env` link. However, created `jvu` environment is actually inherited from validator environment, so you can use it if it does not intercept. This is done for the reason to decrease API changes needed to integrate `jvu` to existing code.

Use `add` to add json schema after initialization
```
jvu.add('', jsonSchema);
```

### jvu('', {}) or validate

Use `validate/is` to validate an object by schema reference
```
jvu.validate('#/common', { type: 'common' }) // => true
jvu.is('#/common', { type: 'common' }) // => true
```

`jvu('')` is a short notation for `validate`.
When it's called without a second argument returns a validation function, which can be used in further calculations.
```
jvu('#/common', { type: 'common' }) // => true
...
const validate = jvu('#/common');
validate({ type: 'common' }) // => true
```

### jvu('') or generate

One of the `jvu` public methods is `generate` which literally generates a validation function from a registered json schema path. The validation function accept object as a param and returns `Boolean` flag, if an object matches to a given path.
For easily usage `generate` has a shorthand, which is `jvu` itself with first argument given as a path or schema. This doesn't conflict with `validate/is` method or its shorthand:
- one argument - partial execution,
- two arguments - returns a value.
Don't afraid to use `generate` function often - it caches all generated validation functions, so for one environment it will generate 1 function for 1 path.
```JavaScript
var testCommon = jvu('#/common');
[commonObj].map(testCommon) // => [true]

var testNotCommon = jvu.generate('#/common', true);
[commonObj].map(testNotCommon) // => [false]
```
`Generate` method is very helpful in `each`, `find` and other iterable functions.

### jvu.match({}, ?)

Use `match` as a [Matching pattern](https://en.wikipedia.org/wiki/Pattern_matching).

```
jvu.match({ '#/common': () => 1 }, commonObj) // => 1
jvu.match({ '#/common': () => 1 }, unknownObj) // => undefined
```

Factorial example from [funcy](https://github.com/bramstein/funcy) package
```
const fact = jvu.match({
    '#/0': () => 1,
    '#/other': n => n * fact(n - 1)
});

fact(5) // => 120
```

Immediate execution
```
jvu.match({
    '#/0': () => 0,
    '#/other': () => 1
}, 0); // => 1
```

[if-less](http://alisnic.github.io/posts/ifless/)
```
/**
if(doSomething() === null)
  #something is wrong
else
  #process
*/// =>

jvu.match({
  '#/null': () => NaN,
  '#/other': () => 1,
})(doSomething())
```

A better example of `if-less` or `Matching Pattern` would be a stream (in Reactive Programming) or Promise chain
```
new Promise((resolve, reject) => resolve({ type: 'common' }))
.then(
    jvu.match({
        '#/null': () => 'so far so good',
        '#/common': () => 'common',
        '#/other': () => 'enough',
    }),
    jvu.match({
        '#/error/system': () => 'this is bad',
        '#/error/common': () => '\_(ツ)_/¯',
    })
)
.then(result => console.log(result)); // => 'common'
```

### jvu.find({}, ?)

Use `find` to ease a `switch` condition. A difference between `match` is that `find` only returns a given result, when `match` is also executing found expression. Both `find` and `match` method can use either object or array as a param.
```
jvu.find(['#/common'], commonObj) // => 0
jvu.find({ '#/common': 1 }, unknownObj) // => undefined
```

## API

- **add(String namespace, Object jsonSchema)** add schema to existing environment
- **jvu(String reference[, Boolean isReverse])** generates function to use in functional expressions, shorthands - **generate**
- **jvu(String/Object reference[, Object instance])** validate object by schema reference, shorthands - **validate**, **is**
- **match(Object/Array types[, Object instance])** iterates through an object or array to match appropriate schema to given argument. Executes found function. Returns `undefined` if not found.
- **find(Object/Array types[, Object instance])** iterates through an object or array to find appropriate schema to given argument. Returns `undefined` if not found.
- **env** original environment

## References

- [djv - dynamic json-schema validator](https://www.npmjs.com/package/djv)
- [funcy - Functional Pattern Matching in JavaScript](https://github.com/bramstein/funcy)